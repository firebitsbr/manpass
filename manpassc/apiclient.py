#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Thu Apr 15 22:20:13 2010

#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      hujun
#
# Created:     29/06/2015
# Copyright:   (c) hujun 2015
# Licence:     <your licence>
#-------------------------------------------------------------------------------
from datetime import datetime
import nacl.encoding
import ssl
import httplib
import passcrypto
import hashlib
import json
import common
import os.path
import wx
import multiprocessing
import traceback

_ = wx.GetTranslation



def loadCAFile(uname,passwd,fpath):
    #load a encrypted CA cert encoded in Base32
    cafile=os.path.join(fpath,"ca.cert")
    inf=open(cafile,"r")
    cipher=inf.read()
    inf.close()
    return passcrypto.DecryptMeBase32(cipher,passwd)

def genMetaid(meta,uname):
    n_meta=meta
    n_uname=uname
    if isinstance(meta,unicode):
        n_meta=meta.encode("utf-8")
    if isinstance(uname,unicode):
        n_uname=uname.encode("utf-8")
    m=hashlib.new("sha256")
    m.update(n_meta.strip()+n_uname.strip())
    return m.hexdigest()

class APITransactionError(Exception):
    def __init__(self,conn,msg):
        self.conn=conn
        self.msg=msg

    def __str__(self):
        return "API Transcation Error with {host}:{port}".format(
            host=self.conn.host,port=self.conn.port) + repr(self.msg)



class APIClient:
    def __init__(self,svrhost,svrport,cadata,certfile,keyfile,masterpass,dpool,epool):
        #cadata is DER encoded CA cert, string
        #certfile/keyfile is filename/path of PEM encoded file
        #keyfile is encrypted PEM
        self.masterpass=masterpass
        self.ctx=ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        self.ctx.load_cert_chain(certfile,keyfile,self.masterpass)
        self.ctx.load_verify_locations(cadata=cadata)
        self.ctx.verify_mode=ssl.CERT_REQUIRED
        self.conn=httplib.HTTPSConnection(svrhost,svrport,context=self.ctx)
        self.urlpath="/client"
        self.DWorkerPool=dpool
        self.EWorkerPool=epool

    def add(self,meta,uname,passwd):
        self.EWorkerPool.taskQ.put((meta,uname,passwd,-1,self.masterpass))
        body=json.dumps(self.EWorkerPool.doneQ.get())
        self.conn.request("POST",self.urlpath,body)
        resp=self.conn.getresponse()
        if resp.status!=201:
            raise APITransactionError(self.conn,"Failed to create record")
        resp.read()


    def addlist(self,plist,win=None):
        for p in plist:
            self.EWorkerPool.taskQ.put(p['meta'],p['uname'],p['pass'],-1,self.masterpass)




    def get(self,meta,uname,pass_rev=-1):
    #by default, reve=-1, it will return the latest reversion password
        meta_id=genMetaid(meta,uname)
        q={"meta_id":meta_id,"pass_rev":pass_rev}
        self.conn.request("GET",self.urlpath,json.dumps(q))
        resp=self.conn.getresponse()
        if resp.status !=200:
            if resp.status==204:
                resp.read()
                return None
            else:
                raise APITransactionError(self.conn,"Failed to get record")
        else:
            raw_body=resp.read()
            r=json.loads(raw_body)
            self.DWorkerPool.taskQ.put((r,self.masterpass))
            nr=self.DWorkerPool.doneQ.get()
            return nr

    def remove(self,meta,uname,pass_rev=None):
        meta_id=genMetaid(meta,uname)
        if pass_rev!=None:
            q={"meta_id":meta_id,"pass_rev":pass_rev}
        else:
            q={"meta_id":meta_id}
        self.conn.request("DELETE",self.urlpath,json.dumps(q))
        resp=self.conn.getresponse()
        if resp.status !=200:
            raise APITransactionError(self.conn,"Failed to remove record")
        resp.read()






    def getAllRecodsForMeta(self,meta=None,uname=None,mid=None,win=None):
        if mid==None:
            meta_id=genMetaid(meta,uname)
        else:
            meta_id=mid
        q={"meta_id":meta_id}
        try:
            self.conn.request("GET",self.urlpath,json.dumps(q))
            resp=self.conn.getresponse()
            if resp.status !=200:
                if resp.status==204:
                    resp.read()
                    if win!=None:
                        devt=common.ManpassLoadingDone(plist=[])
                        wx.PostEvent(win,devt)
                    return []
                else:
                    raise APITransactionError(self.conn,"Failed to get record")
            else:
                raw_body=resp.read()
                rlist=json.loads(raw_body)
##                for r in rlist:
##                    self.decryptRecordWithSingleSalt(r)
                for r in rlist:
                    self.DWorkerPool.taskQ.put((r,self.masterpass))
                nr_list=[]
                list_len=len(rlist)
                for i in range(list_len):
                    nr_list.append(self.DWorkerPool.doneQ.get())
                if win!=None:
                    devt=common.ManpassLoadingDone(plist=nr_list)
                    wx.PostEvent(win,devt)
                return rlist
        except Exception as Err:
            if win==None:
                raise Err
            else:
                eevt=common.ManpassErrEVT(Value=unicode(Err))
                wx.PostEvent(win,eevt)
                return []

    def getAllMetaId(self):
        self.conn.request("GET",self.urlpath+"/meta-id")
        print self.urlpath+"/meta-id"
        resp=self.conn.getresponse()
        if resp.status !=200:
            resp.read()
            if resp.status==204:
                return []
            else:
                raise APITransactionError(self.conn,"Failed to get record")
        else:
            raw_body=resp.read()
            print raw_body
            rlist=json.loads(raw_body)
            return rlist


    def getAll(self,win=None):
        try:
            self.conn.connect()
            self.conn.request("GET",self.urlpath)
            resp=self.conn.getresponse()
            if resp.status !=200:
                resp.read()
                if resp.status==204:
                    if win!=None:
                        resp.read()
                        fevt=common.ManpassLoadingDone(Passlist=[])
                        wx.PostEvent(win,fevt)
                    return []
                else:
                    print resp.status
                    raise APITransactionError(self.conn,"Failed to get record")
            else:
                raw_body=resp.read()
                rlist=json.loads(raw_body)

                for r in rlist:
                    self.DWorkerPool.taskQ.put((r,self.masterpass))
                nr_list=[]
                i=0
                list_len=len(rlist)
                for i in range(list_len):
                    nr_list.append(self.DWorkerPool.doneQ.get())
                    pevt=common.ManpassProgressEVT(Range=list_len,Pos=i)
                    wx.PostEvent(win,pevt)
                    i+=1
                if win!=None:
                    fevt=common.ManpassLoadingDone(Passlist=nr_list)
                    wx.PostEvent(win,fevt)
                return nr_list
        except Exception as Err:
            traceback.print_exc(Err)
            if win!=None:
                eevt=common.ManpassFatalErrEVT(Value=_("Unable to get records!\n")+unicode(Err))
                wx.PostEvent(win,eevt)
                return []
            else:
                raise Err




    def getAllLatest(self,win=None):
        q={"meta_id":"__ALLLATESTPASS__"}
        try:
            self.conn.connect()
            self.conn.request("GET",self.urlpath,json.dumps(q))
            resp=self.conn.getresponse()
            if resp.status !=200:
                resp.read()
                if resp.status==204:
                    if win!=None:
                        resp.read()
                        fevt=common.ManpassLoadingDone(Passlist=[])
                        wx.PostEvent(win,fevt)
                    return []
                else:
                    raise APITransactionError(self.conn,"Failed to get record")
            else:
                raw_body=resp.read()
                rlist=json.loads(raw_body)

                for r in rlist:
                    self.DWorkerPool.taskQ.put((r,self.masterpass))
                nr_list=[]
                i=0
                list_len=len(rlist)
                for i in range(list_len):
                    nr_list.append(self.DWorkerPool.doneQ.get())
                    pevt=common.ManpassProgressEVT(Range=list_len,Pos=i)
                    wx.PostEvent(win,pevt)
                    i+=1


                if win!=None:
                    fevt=common.ManpassLoadingDone(Passlist=nr_list)
                    wx.PostEvent(win,fevt)
                return nr_list
        except Exception as Err:
            traceback.print_exc(Err)
            if win!=None:
                eevt=common.ManpassFatalErrEVT(Value=_("Unable to get records!\n")+unicode(Err))
                wx.PostEvent(win,eevt)
                return []
            else:
                raise Err


    def replaceAll(self,rlist,newpass,win=None):
        reqlist=[]
        i=0

        for r in rlist:
            self.EWorkerPool.taskQ.put((r['Meta'],r['Uname'],r['Pass'],r['Pass_rev'],newpass))
        list_len=len(rlist)
        for i in range(list_len):
            reqlist.append(self.EWorkerPool.doneQ.get())
            pevt=common.ManpassProgressEVT(Range=list_len,Pos=i)
            wx.PostEvent(win,pevt)
            i+=1
        body=json.dumps(reqlist)
        self.conn.request("PUT",self.urlpath,body)
        resp=self.conn.getresponse()
        if resp.status!=200:
            raise APITransactionError(self.conn,"Failed to replace records")
        resp.read()


##    def genRecord(self,meta,uname,passwd,mpass=None):
##        #return a record, meta,uname,passwd are encrypted with passwd
##        r={}
##        n_meta=meta
##        n_uname=uname
##        n_passwd=passwd
##        if isinstance(meta,unicode):
##            n_meta=meta.encode("utf-8")
##        if isinstance(uname,unicode):
##            n_uname=uname.encode("utf-8")
##        if isinstance(passwd,unicode):
##            n_passwd=passwd.encode("utf-8")
##        r['meta_id']=genMetaid(meta,uname)
##        salt=passcrypto.GenerateSalt()
##        if mpass==None:
##            mp=self.masterpass
##        else:
##            mp=mpass
##        skey=passcrypto.GenerateEncKey(mp,salt)
##        r['meta']=passcrypto.EncryptWithoutSaltBase32(n_meta,skey,salt)
##        r['uname']=passcrypto.EncryptWithoutSaltBase32(n_uname,skey,salt)
##        r['pass']=passcrypto.EncryptWithoutSaltBase32(n_passwd,skey,salt)
##        #return json.dumps(r)
##        return r

def genRecord(inputQ,outputQ):
    #return a record, meta,uname,passwd are encrypted with passwd
    try:
        while True:
            (meta,uname,passwd,pass_rev,mpass)=inputQ.get()
            r={}
            n_meta=meta
            n_uname=uname
            n_passwd=passwd
            if isinstance(meta,unicode):
                n_meta=meta.encode("utf-8")
            if isinstance(uname,unicode):
                n_uname=uname.encode("utf-8")
            if isinstance(passwd,unicode):
                n_passwd=passwd.encode("utf-8")
            r['meta_id']=genMetaid(meta,uname)
            salt=passcrypto.GenerateSalt()
            mp=mpass
            skey=passcrypto.GenerateEncKey(mp,salt)
            r['meta']=passcrypto.EncryptWithoutSaltBase32(n_meta,skey,salt)
            r['uname']=passcrypto.EncryptWithoutSaltBase32(n_uname,skey,salt)
            r['pass']=passcrypto.EncryptWithoutSaltBase32(n_passwd,skey,salt)
            if pass_rev!=-1:
                r['pass_rev']=pass_rev
            #return json.dumps(r)
            outputQ.put(r)
    except Exception as Err:
        print traceback.format_exc()




def decryptRecordWithSingleSalt(inputQ,outputQ):
    try:
        while True:
            (cipherR,masterpass)=inputQ.get()
            RR={}
            enc=nacl.encoding.Base32Encoder()
            ds=enc.decode(cipherR['Pass'])
            skey=passcrypto.GenerateEncKey(masterpass,ds[:passcrypto.SaltSize])
            for k,v in cipherR.items():
                if k=='Uname' or k=="Pass" or k=='Meta':
                    ds=enc.decode(v)
                    RR[k]=passcrypto.DecryptWithoutSalt(ds[passcrypto.SaltSize:],skey)

            for k,v in RR.items():
                if k=="Uname" or k=="Meta":
                    RR[k]=RR[k].decode('utf-8')
            RR["Pass_rev"]=cipherR['Pass_rev']
            RR["Pass_time"]=common.getLocalTime(cipherR['Pass_time'])
            outputQ.put(RR)
    except Exception as Err:
        print traceback.format_exc()



