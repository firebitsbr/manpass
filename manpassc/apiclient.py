#!/usr/bin/env python
# -*- coding: utf-8 -*-
# generated by wxGlade 0.6.3 on Thu Apr 15 22:20:13 2010

#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      hujun
#
# Created:     29/06/2015
# Copyright:   (c) hujun 2015
# Licence:     <your licence>
#-------------------------------------------------------------------------------
from datetime import datetime
import nacl.encoding
import ssl
import httplib
import passcrypto
import hashlib
import json
import common
import os.path
import wx

_ = wx.GetTranslation

def loadCAFile(uname,passwd,fpath):
    #load a encrypted CA cert encoded in Base32
    cafile=os.path.join(fpath,"ca.cert")
    inf=open(cafile,"r")
    cipher=inf.read()
    inf.close()
    return passcrypto.DecryptMeBase32(cipher,passwd)

def genMetaid(meta,uname):
    n_meta=meta
    n_uname=uname
    if isinstance(meta,unicode):
        n_meta=meta.encode("utf-8")
    if isinstance(uname,unicode):
        n_uname=uname.encode("utf-8")
    m=hashlib.new("sha256")
    m.update(n_meta.strip()+n_uname.strip())
    return m.hexdigest()

class APITransactionError(Exception):
    def __init__(self,conn,msg):
        self.conn=conn
        self.msg=msg

    def __str__(self):
        return "API Transcation Error with {host}:{port}".format(
            host=self.conn.host,port=self.conn.port) + repr(self.msg)



class APIClient:
    def __init__(self,svrhost,svrport,cadata,certfile,keyfile,masterpass):
        #cadata is DER encoded CA cert, string
        #certfile/keyfile is filename/path of PEM encoded file
        #keyfile is encrypted PEM
        self.masterpass=masterpass
        self.ctx=ssl.SSLContext(ssl.PROTOCOL_SSLv23)
        self.ctx.load_cert_chain(certfile,keyfile,self.masterpass)
        self.ctx.load_verify_locations(cadata=cadata)
        self.ctx.verify_mode=ssl.CERT_REQUIRED
        self.conn=httplib.HTTPSConnection(svrhost,svrport,context=self.ctx)
        self.urlpath="/client"

    def add(self,meta,uname,passwd):
        body=json.dumps(self.genRecord(meta,uname,passwd))
        self.conn.request("POST",self.urlpath,body)
        resp=self.conn.getresponse()
        if resp.status!=201:
            raise APITransactionError(self.conn,"Failed to create record")
        resp.read()


    def get(self,meta,uname,pass_rev=-1):
    #by default, reve=-1, it will return the latest reversion password
        meta_id=genMetaid(meta,uname)
        q={"meta_id":meta_id,"pass_rev":pass_rev}
        self.conn.request("GET",self.urlpath,json.dumps(q))
        resp=self.conn.getresponse()
        if resp.status !=200:
            if resp.status==204:
                resp.read()
                return None
            else:
                raise APITransactionError(self.conn,"Failed to get record")
        else:
            raw_body=resp.read()
            r=json.loads(raw_body)
            self.decryptRecordWithSingleSalt(r)
            return r

    def remove(self,meta,uname,pass_rev=None):
        meta_id=genMetaid(meta,uname)
        if pass_rev!=None:
            q={"meta_id":meta_id,"pass_rev":pass_rev}
        else:
            q={"meta_id":meta_id}
        self.conn.request("DELETE",self.urlpath,json.dumps(q))
        resp=self.conn.getresponse()
        if resp.status !=200:
            raise APITransactionError(self.conn,"Failed to remove record")
        resp.read()






    def getAllRecodsForMeta(self,meta=None,uname=None,mid=None,win=None):
        if mid==None:
            meta_id=genMetaid(meta,uname)
        else:
            meta_id=mid
        q={"meta_id":meta_id}
        try:
            self.conn.request("GET",self.urlpath,json.dumps(q))
            resp=self.conn.getresponse()
            if resp.status !=200:
                if resp.status==204:
                    resp.read()
                    if win!=None:
                        devt=common.ManpassLoadingDone(plist=[])
                        wx.PostEvent(win,devt)
                    return []
                else:
                    raise APITransactionError(self.conn,"Failed to get record")
            else:
                raw_body=resp.read()
                rlist=json.loads(raw_body)
                for r in rlist:
                    self.decryptRecordWithSingleSalt(r)
                if win!=None:
                    devt=common.ManpassLoadingDone(plist=rlist)
                    wx.PostEvent(win,devt)
                return rlist
        except Exception as Err:
            if win==None:
                raise Err
            else:
                eevt=common.ManpassErrEVT(Value=unicode(Err))
                wx.PostEvent(win,eevt)
                return []

    def getAllMetaId(self):
        self.conn.request("GET",self.urlpath+"/meta-id")
        print self.urlpath+"/meta-id"
        resp=self.conn.getresponse()
        if resp.status !=200:
            resp.read()
            if resp.status==204:
                return []
            else:
                raise APITransactionError(self.conn,"Failed to get record")
        else:
            raw_body=resp.read()
            print raw_body
            rlist=json.loads(raw_body)
            return rlist




    def getAllLatest(self,win=None):
        q={"meta_id":"__ALLLATESTPASS__"}
        try:
            self.conn.connect()
            self.conn.request("GET",self.urlpath,json.dumps(q))
            resp=self.conn.getresponse()
            if resp.status !=200:
                resp.read()
                if resp.status==204:
                    if win!=None:
                        resp.read()
                        fevt=common.ManpassLoadingDone(Passlist=[])
                        wx.PostEvent(win,fevt)
                    return []
                else:
                    raise APITransactionError(self.conn,"Failed to get record")
            else:
                raw_body=resp.read()
                rlist=json.loads(raw_body)
                i=0
                for r in rlist:
                    self.decryptRecordWithSingleSalt(r)
                    i+=1
                    if win!=None:
                        uevt=common.ManpassProgressEVT(Range=len(rlist),Pos=i)
                        wx.PostEvent(win,uevt)
                if win!=None:
                    fevt=common.ManpassLoadingDone(Passlist=rlist)
                    wx.PostEvent(win,fevt)
                return rlist
        except Exception as Err:
            if win!=None:
                eevt=common.ManpassFatalErrEVT(Value=_("Unable to get reconds!\n")+unicode(Err))
                wx.PostEvent(win,eevt)
                return []
            else:
                raise Err


    def replaceAll(self,rlist,newpass,win=None):
        reqlist=[]
        i=0
        for r in rlist:
            if win!=None:
                i+=1
                pevt=common.ManpassProgressEVT(Range=len(rlist),Pos=i)
                wx.PostEvent(win,pevt)
            req=self.genRecord(r['Meta'],r['Uname'],r['Pass'],newpass)
            req['pass_rev']=r['Pass_rev']
            reqlist.append(req)
        body=json.dumps(reqlist)
        self.conn.request("PUT",self.urlpath,body)
        resp=self.conn.getresponse()
        if resp.status!=200:
            raise APITransactionError(self.conn,"Failed to replace records")
        resp.read()


    def genRecord(self,meta,uname,passwd,mpass=None):
        #return a record, meta,uname,passwd are encrypted with passwd
        r={}
        n_meta=meta
        n_uname=uname
        n_passwd=passwd
        if isinstance(meta,unicode):
            n_meta=meta.encode("utf-8")
        if isinstance(uname,unicode):
            n_uname=uname.encode("utf-8")
        if isinstance(passwd,unicode):
            n_passwd=passwd.encode("utf-8")
        r['meta_id']=genMetaid(meta,uname)
        salt=passcrypto.GenerateSalt()
        if mpass==None:
            mp=self.masterpass
        else:
            mp=mpass
        skey=passcrypto.GenerateEncKey(mp,salt)
        r['meta']=passcrypto.EncryptWithoutSaltBase32(n_meta,skey,salt)
        r['uname']=passcrypto.EncryptWithoutSaltBase32(n_uname,skey,salt)
        r['pass']=passcrypto.EncryptWithoutSaltBase32(n_passwd,skey,salt)
        #return json.dumps(r)
        return r


    def decryptRecordWithSingleSalt(self,cipherR):
        enc=nacl.encoding.Base32Encoder()
        ds=enc.decode(cipherR['Pass'])
        skey=passcrypto.GenerateEncKey(self.masterpass,ds[:passcrypto.SaltSize])
        for k,v in cipherR.items():
            if k=='Uname'  or k=='Meta':
                ds=enc.decode(v)
                cipherR[k]=passcrypto.DecryptWithoutSalt(ds[passcrypto.SaltSize:],skey)

        for k,v in cipherR.items():
            if k=="Uname" or k=="Meta":
                cipherR[k]=cipherR[k].decode('utf-8')
        cipherR["Pass_time"]=common.getLocalTime(cipherR['Pass_time'])



def main():
    upass="zifan234"
    uname="hujun"
    cadata=loadCAFile(uname,upass,common.getConfDir(uname))
    ac=APIClient("127.0.0.1",8030,cadata,
        os.path.join(common.getConfDir(uname),"ee.cert"),
        os.path.join(common.getConfDir(uname),"ee.key"),upass)
##    ac.add(u"谷歌","zifan","alu123")
##    ac.add(u"谷歌","zifan","alu456")
##    ac.add(u"yahoo","dongtian","alu456")
##    #ac.get(u"谷歌")
##    ac.remove(u"yahoo",2)
##    print ac.getAllLatest()
##    #ac.getAllRecodsForMeta(u"谷歌1")
## #   print genRecord(u"谷歌","zifan","alu123")
    #print ac.getAllRecodsForMeta("meta-23","user-23")
    print ac.getAllMetaId()
if __name__ == '__main__':
    main()
